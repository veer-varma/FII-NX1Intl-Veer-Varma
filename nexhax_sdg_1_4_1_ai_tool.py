# -*- coding: utf-8 -*-
"""NexHax SDG 1.4.1 AI Tool

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dKeQtCrwWhLTgMUj7Qm2Zk96u2V9Mj_V

# Import Libraries
"""

import pandas as pd
import numpy as np
import torch
import torch.nn as nn
from torch.utils.data import Dataset, DataLoader
import plotly.express as px
from functools import lru_cache
import gradio as gr

"""## Dataset"""

# Upload your dataset
from google.colab import files
uploaded = files.upload()  # This will prompt you to select a file

filename = list(uploaded.keys())[0]  # Gets the uploaded file name

# For .ods files, make sure odfpy is installed
!pip install odfpy

# Read the .ods file
df = pd.read_excel(filename, engine='odf')

# Inspect the data
print("Dataset preview:")
print(df.head())
print("Sheet columns:", df.columns)

"""## LSTM model

"""

# LSTM model for time series forecasting
class LSTM(nn.Module):
    def __init__(self, input_size=1, hidden_size=20, output_size=1):
        super().__init__()
        self.lstm = nn.LSTM(input_size, hidden_size, batch_first=True)
        self.linear = nn.Linear(hidden_size, output_size)

    def forward(self, x):
        # x: [batch, seq_len, features]
        out, _ = self.lstm(x)
        out = self.linear(out[:, -1, :])  # take the last timestep
        return out

"""# Dataset for time Series"""

# Dataset class for sliding windows
class TimeSeriesDataset(Dataset):
    def __init__(self, series, window_size=3):
        self.series = torch.tensor(series, dtype=torch.float32).unsqueeze(-1)  # [seq, 1]
        self.window_size = window_size

    def __len__(self):
        return max(0, len(self.series) - self.window_size)

    def __getitem__(self, idx):
        return self.series[idx:idx+self.window_size], self.series[idx+self.window_size]

"""## Train LSTM"""

# Function to train LSTM on a series
def train_lstm(values, window_size=3, epochs=500, lr=0.01):
    if len(values) < window_size + 1:
        return None  # Not enough data
    values_norm = np.array(values) / 100.0
    dataset = TimeSeriesDataset(values_norm, window_size)
    loader = DataLoader(dataset, batch_size=1, shuffle=True)
    model = LSTM()
    optimizer = torch.optim.Adam(model.parameters(), lr=lr)
    loss_fn = nn.MSELoss()
    model.train()
    for epoch in range(epochs):
        for seq, label in loader:
            pred = model(seq)
            loss = loss_fn(pred, label)
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()

    return model

"""# Function to predict the goal year"""

# Function to predict the year when value reaches 100 using the model
@lru_cache(maxsize=None)
def predict_year_for_series(country, location, series_code):
    group = df[(df['GeoAreaName'] == country) & (df['Location'] == location) & (df['SeriesCode'] == series_code)]
    if group.empty:
        return None
    group = group.sort_values('TimePeriod')
    years = group['TimePeriod'].values
    values = group['Value'].values

    # Check if already achieved in historical data
    achieved_idx = np.where(values >= 100)[0]
    if len(achieved_idx) > 0:
        return years[achieved_idx[0]]

   # Train model
    window_size = 3
    model = train_lstm(values, window_size)
    if model is None:
        return None

    current_year = years[-1]
    current_series = list(values / 100.0)
    max_year = 2100
    while current_series[-1] < 1.0 and current_year < max_year:
        last_window = torch.tensor(current_series[-window_size:], dtype=torch.float32).unsqueeze(-1).unsqueeze(0)  # [batch, seq, feat]
        model.eval()
        with torch.no_grad():
            pred_norm = model(last_window).item()
        pred_value = pred_norm * 100
        if pred_value >= 100:
            return current_year + 1
        # If not increasing significantly, stop to avoid infinite loop
        if pred_norm <= current_series[-1]:
            return None
        current_series.append(pred_norm)
        current_year += 1
    return None if current_year >= max_year else current_year + 1

"""# Load DataSet"""

try:
    df = pd.read_excel(filename, engine='odf')
    df = df[df['Indicator'] == '1.4.1']
    df = df[['GeoAreaName', 'Location', 'SeriesCode', 'TimePeriod', 'Value']]
    df = df[df['GeoAreaName'] != 'World']
    print("Data loaded successfully from ODS file.")
except FileNotFoundError:
    print(f"Error: File '{filename}' not found. Please make sure the file is uploaded.")
except Exception as e:
    print(f"An error occurred while reading the ODS file: {e}")

# Unique countries and locations
countries = sorted(df['GeoAreaName'].unique())
locations = sorted(df['Location'].unique())
series_water = 'SP_ACS_BSRVH2O'
series_san = 'SP_ACS_BSRVSAN'

"""# Precompute for faster processing"""

# Precompute predicted years
precomp_data = []
for country in countries:
    for loc in locations:
        year_water = predict_year_for_series(country, loc, series_water)
        year_san = predict_year_for_series(country, loc, series_san)
        if year_water is None or year_san is None:
            overall_year = None
        else:
            overall_year = max(year_water, year_san)
        precomp_data.append({
            'GeoAreaName': country,
            'Location': loc,
            'Water_Year': year_water if year_water else 'Never',
            'Sanitation_Year': year_san if year_san else 'Never',
            'Overall_Year': overall_year if overall_year else 'Never'
        })

precomp_df = pd.DataFrame(precomp_data)

"""## Create Gradio Interface"""

def predict_year(country, location, series_code):
    year = predict_year_for_series(country, location, series_code)
    if year:
        return f"Predicted year to reach 100%: {year}"
    else:
        return "Prediction not possible with available data or already achieved/stagnated."

# Get unique values for dropdowns
countries = df['GeoAreaName'].unique().tolist()
locations = df['Location'].unique().tolist()
series_codes = df['SeriesCode'].unique().tolist()

with gr.Blocks() as demo:
    gr.Markdown("## Predict Year to Reach 100%")
    with gr.Row():
        country_dropdown = gr.Dropdown(choices=countries, label="Select Country")
        location_dropdown = gr.Dropdown(choices=locations, label="Select Location")
        series_code_dropdown = gr.Dropdown(choices=series_codes, label="Select Series Code")
    predict_button = gr.Button("Predict")
    output_text = gr.Textbox(label="Prediction Result")

    predict_button.click(fn=predict_year, inputs=[country_dropdown, location_dropdown, series_code_dropdown], outputs=output_text)

demo.launch()